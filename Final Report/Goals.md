The goals of our final project were to determine the most effective route from point A to point B, while visiting popular tourist attractions along the route. With winter holidays approaching, many families might be seeking to plan vacations; however, with increasing travel restrictions due to COVID-19, international vacations might not be the safest option. As a result, we decided to build a tool that will allow for travel within the contiguous United States in the form of a road trip! The tool utilizes a starting state and ending state as inputs, determines the most efficient route between point A and point B, and produces a list of all popular tourist attractions you can visit along the way. The list is also represented visually on a map of the contiguous United States of America. 

For our final project, our team utilized a dataset of popular tourist destinations within the contiguous USA. This dataset contained 4 attributes across 105 observations: Name, Latitudinal coordinate, Longitudinal coordinates, and State. The data originated from https://www.touristmaker.com/blog/100-sights-in-usa/, was converted into an excel spreadsheet with each observation representing a destination, and finally transformed into a .csv format to easily parse through the data. For the purposes of our final project, we extracted the name, latitude, longitude, and state, placed the values into a struct labeled Location, and added each Location into a vector where each index represents a unique location. The data was organized in this manner so we would be able to determine all possible pathways between point A and point B, calculate distances between locations within a specific path, and produce graphical representations of the most efficient route. 

In addition to our dataset of destinations, we obtained a dataset of neighboring states within the contiguous USA. This dataset includes 218 elements in which each element contains two states, the first state being the state of focus and the second state being one of the neighboring states. If a state of focus has multiple neighboring states, then the state of focus will have multiple and an equal number of data points, showcasing all the neighboring states. For example, Colorado has 6 neighboring states, so there are 6 data points for CO where each represents a single neighboring state to Colorado, but since California only has 3 neighboring states, CA has 3 data points. The data originated from https://github.com/ubikuity/List-of-neighboring-states-for-each-US-state in the form of a csv and was converted into a vector within our nodes. This vector is a list of neighboring states for each node, state, in our dataset. The data was organized in this manner so we would be able to derive a number of ways to travel between a starting state and an ending state, and thus determine the most efficient route, which we defined earlier as the route with lowest distance and most number of tourist attractions. 

The algorithms we have chosen to implement are Dijkstra’s algorithm, Kruskal’s minimum spanning tree algorithm, and a Breadth-First Search algorithm. Dijkstra’s algorithm takes a start point and end point, both integers, in as inputs; the algorithm uses these inputs to access our data-set and find the corresponding beginning and destination states. After finding these states, it calculates every possible path (connected edges) between the two states, and calculates the edge weight as well as the total distance in kilometers (using a latitude/longitude math matrix which can be found in calculator.cpp), and then selects the shortest path out of all of them as the output. This path is then stored in a vector (so it can be accessed later), and then printed to the terminal along with each stop and the distance required to travel along said path. This algorithm works in union with Kruskal’s algorithm, as kruskal’s outputs the nearby tourist attractions on the way of the shortest path. Kruskal’s takes in no parameters, but uses an adjacency matrix and list to find the minimum distance to an attraction at each pitstop along the way of the shortest path. Since both these algorithms appear in the same file, they can interchangeably access the same vectors, thus working in synchrony. Our third algorithm is a Breadth-First Search which again takes in start and end integers, and traverses the graph (corresponding to the United States map for our purposes) starting at the starting node (state), and continuing laywise (exploring neighboring nodes using our adjacency matrix), before eventually locating the end node. To summarize, Kruskal’s algorithm is used to find nearby attractions along the shortest path, which is determined by Dijkstra’s algorithm. We locate each of these locations and states using a BFS-search, which is programmed with an adjacency matrix. These are how our three algorithms work in synchrony to build the base of our road-trip planner final project!

The final deliverable of our project includes an efficient travel pathway that begins in the starting state, ends in the ending state, and travels through a number of popular destinations that lie within the states along the route. This efficient path is developed through a series of algorithms that first determine the most efficient states to travel through based on distance given a starting and ending state, then determine a list of destinations that are located within the states, and finally choose a list of destinations that produce an efficient path based on distance traveled. While this list is printed to the terminal, we believed the best representation of the success of our algorithms would be in a graphical representation of the list, given our project plans a trip across the United States. For this reason, we converted the list into a visual output that plots points and lines on a United States map outlining the efficient route. We accomplished this by extracting the latitude and longitude from each location along the efficient route, converting the coordinates to appropriate pixels based on our US map image in order to plot a point at each destination, and drawing lines from one destination to another to signify the order in which each destination is visited. 

Lastly, in order to adhere to goals presented above and in our former scoping documents, we developed a timeline and workstreams for each member to accomplish our goals. Our first task, in which we allocated three days (11/21-11/24), was to parse our finalized dataset and build guidelines for how to construct our graph structures with weights. Once we completed the initial framework of our implementation using structs, we set our input and output for the project, in this instance a start/end state and a graphical representation of the route a user would take, and began to represent our graph as an Adjacency Matrix/List with the weight being the distance (11/24-11/28). Our third task then revolved around building our three algorithms: Dijsktra's, BFS, and Kruskals, in which each would assist us towards producing a list of tourist attractions along the route (11/28-12/4). Upon completing development of our algorithms and performing testing, the team worked towards printing the output of each algorithm to the terminal, utilizing the PNG class to visually represent the route, and beginning documentation for our written report (12/5 - 12/8). In the last days of the project, the team collaborated to create and record our final presentation, outline our overall goals, development, and deliverables in our written report, and ensure our code-base is functional and works as intended (12/9 - 12/13). 

